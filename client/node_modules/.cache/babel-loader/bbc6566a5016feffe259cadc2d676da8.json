{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { noop, parseMutationArgs } from '../core/utils';\nimport { MutationObserver } from '../core/mutationObserver';\nimport { useQueryClient } from './QueryClientProvider';\nimport { useIsMounted } from './useIsMounted'; // HOOK\n\nexport function useMutation(arg1, arg2, arg3) {\n  var isMounted = useIsMounted();\n  var options = parseMutationArgs(arg1, arg2, arg3);\n  var queryClient = useQueryClient(); // Create mutation observer\n\n  var observerRef = React.useRef();\n  var observer = observerRef.current || new MutationObserver(queryClient, options);\n  observerRef.current = observer; // Update options\n\n  if (observer.hasListeners()) {\n    observer.setOptions(options);\n  }\n\n  var _React$useState = React.useState(function () {\n    return observer.getCurrentResult();\n  }),\n      currentResult = _React$useState[0],\n      setCurrentResult = _React$useState[1]; // Subscribe to the observer\n\n\n  React.useEffect(function () {\n    return observer.subscribe(notifyManager.batchCalls(function (result) {\n      if (isMounted()) {\n        setCurrentResult(result);\n      }\n    }));\n  }, [observer, isMounted]);\n  var mutate = React.useCallback(function (variables, mutateOptions) {\n    observer.mutate(variables, mutateOptions).catch(noop);\n  }, [observer]);\n\n  if (currentResult.error && observer.options.useErrorBoundary) {\n    throw currentResult.error;\n  }\n\n  return _extends({}, currentResult, {\n    mutate: mutate,\n    mutateAsync: currentResult.mutate\n  });\n}","map":{"version":3,"sources":["/Users/nicjaws/Documents/GitHub/React/discord-clone/client/node_modules/react-query/es/react/useMutation.js"],"names":["_extends","React","notifyManager","noop","parseMutationArgs","MutationObserver","useQueryClient","useIsMounted","useMutation","arg1","arg2","arg3","isMounted","options","queryClient","observerRef","useRef","observer","current","hasListeners","setOptions","_React$useState","useState","getCurrentResult","currentResult","setCurrentResult","useEffect","subscribe","batchCalls","result","mutate","useCallback","variables","mutateOptions","catch","error","useErrorBoundary","mutateAsync"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SAASC,aAAT,QAA8B,uBAA9B;AACA,SAASC,IAAT,EAAeC,iBAAf,QAAwC,eAAxC;AACA,SAASC,gBAAT,QAAiC,0BAAjC;AACA,SAASC,cAAT,QAA+B,uBAA/B;AACA,SAASC,YAAT,QAA6B,gBAA7B,C,CAA+C;;AAE/C,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiCC,IAAjC,EAAuC;AAC5C,MAAIC,SAAS,GAAGL,YAAY,EAA5B;AACA,MAAIM,OAAO,GAAGT,iBAAiB,CAACK,IAAD,EAAOC,IAAP,EAAaC,IAAb,CAA/B;AACA,MAAIG,WAAW,GAAGR,cAAc,EAAhC,CAH4C,CAGR;;AAEpC,MAAIS,WAAW,GAAGd,KAAK,CAACe,MAAN,EAAlB;AACA,MAAIC,QAAQ,GAAGF,WAAW,CAACG,OAAZ,IAAuB,IAAIb,gBAAJ,CAAqBS,WAArB,EAAkCD,OAAlC,CAAtC;AACAE,EAAAA,WAAW,CAACG,OAAZ,GAAsBD,QAAtB,CAP4C,CAOZ;;AAEhC,MAAIA,QAAQ,CAACE,YAAT,EAAJ,EAA6B;AAC3BF,IAAAA,QAAQ,CAACG,UAAT,CAAoBP,OAApB;AACD;;AAED,MAAIQ,eAAe,GAAGpB,KAAK,CAACqB,QAAN,CAAe,YAAY;AAC/C,WAAOL,QAAQ,CAACM,gBAAT,EAAP;AACD,GAFqB,CAAtB;AAAA,MAGIC,aAAa,GAAGH,eAAe,CAAC,CAAD,CAHnC;AAAA,MAIII,gBAAgB,GAAGJ,eAAe,CAAC,CAAD,CAJtC,CAb4C,CAiBD;;;AAG3CpB,EAAAA,KAAK,CAACyB,SAAN,CAAgB,YAAY;AAC1B,WAAOT,QAAQ,CAACU,SAAT,CAAmBzB,aAAa,CAAC0B,UAAd,CAAyB,UAAUC,MAAV,EAAkB;AACnE,UAAIjB,SAAS,EAAb,EAAiB;AACfa,QAAAA,gBAAgB,CAACI,MAAD,CAAhB;AACD;AACF,KAJyB,CAAnB,CAAP;AAKD,GAND,EAMG,CAACZ,QAAD,EAAWL,SAAX,CANH;AAOA,MAAIkB,MAAM,GAAG7B,KAAK,CAAC8B,WAAN,CAAkB,UAAUC,SAAV,EAAqBC,aAArB,EAAoC;AACjEhB,IAAAA,QAAQ,CAACa,MAAT,CAAgBE,SAAhB,EAA2BC,aAA3B,EAA0CC,KAA1C,CAAgD/B,IAAhD;AACD,GAFY,EAEV,CAACc,QAAD,CAFU,CAAb;;AAIA,MAAIO,aAAa,CAACW,KAAd,IAAuBlB,QAAQ,CAACJ,OAAT,CAAiBuB,gBAA5C,EAA8D;AAC5D,UAAMZ,aAAa,CAACW,KAApB;AACD;;AAED,SAAOnC,QAAQ,CAAC,EAAD,EAAKwB,aAAL,EAAoB;AACjCM,IAAAA,MAAM,EAAEA,MADyB;AAEjCO,IAAAA,WAAW,EAAEb,aAAa,CAACM;AAFM,GAApB,CAAf;AAID","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { noop, parseMutationArgs } from '../core/utils';\nimport { MutationObserver } from '../core/mutationObserver';\nimport { useQueryClient } from './QueryClientProvider';\nimport { useIsMounted } from './useIsMounted'; // HOOK\n\nexport function useMutation(arg1, arg2, arg3) {\n  var isMounted = useIsMounted();\n  var options = parseMutationArgs(arg1, arg2, arg3);\n  var queryClient = useQueryClient(); // Create mutation observer\n\n  var observerRef = React.useRef();\n  var observer = observerRef.current || new MutationObserver(queryClient, options);\n  observerRef.current = observer; // Update options\n\n  if (observer.hasListeners()) {\n    observer.setOptions(options);\n  }\n\n  var _React$useState = React.useState(function () {\n    return observer.getCurrentResult();\n  }),\n      currentResult = _React$useState[0],\n      setCurrentResult = _React$useState[1]; // Subscribe to the observer\n\n\n  React.useEffect(function () {\n    return observer.subscribe(notifyManager.batchCalls(function (result) {\n      if (isMounted()) {\n        setCurrentResult(result);\n      }\n    }));\n  }, [observer, isMounted]);\n  var mutate = React.useCallback(function (variables, mutateOptions) {\n    observer.mutate(variables, mutateOptions).catch(noop);\n  }, [observer]);\n\n  if (currentResult.error && observer.options.useErrorBoundary) {\n    throw currentResult.error;\n  }\n\n  return _extends({}, currentResult, {\n    mutate: mutate,\n    mutateAsync: currentResult.mutate\n  });\n}"]},"metadata":{},"sourceType":"module"}