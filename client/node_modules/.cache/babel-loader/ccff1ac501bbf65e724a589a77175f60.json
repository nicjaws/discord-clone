{"ast":null,"code":"import React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary';\nimport { useQueryClient } from './QueryClientProvider';\nimport { useIsMounted } from './useIsMounted';\nexport function useBaseQuery(options, Observer) {\n  var isMounted = useIsMounted();\n  var queryClient = useQueryClient();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly re-mounting after suspense\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    } // Prevent retrying failed query if the error boundary has not been reset yet\n\n\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  } // Create query observer\n\n\n  var observerRef = React.useRef();\n  var observer = observerRef.current || new Observer(queryClient, defaultedOptions);\n  observerRef.current = observer; // Update options\n\n  if (observer.hasListeners()) {\n    observer.setOptions(defaultedOptions);\n  }\n\n  var currentResult = observer.getCurrentResult();\n\n  var _React$useState = React.useState(currentResult),\n      setCurrentResult = _React$useState[1]; // Subscribe to the observer\n\n\n  React.useEffect(function () {\n    errorResetBoundary.clearReset();\n    return observer.subscribe(notifyManager.batchCalls(function (result) {\n      if (isMounted()) {\n        setCurrentResult(result);\n      }\n    }));\n  }, [observer, errorResetBoundary, isMounted]); // Handle suspense\n\n  if (observer.options.suspense || observer.options.useErrorBoundary) {\n    if (observer.options.suspense && currentResult.isLoading) {\n      errorResetBoundary.clearReset();\n      var unsubscribe = observer.subscribe();\n      throw observer.refetch().finally(unsubscribe);\n    }\n\n    if (currentResult.isError) {\n      throw currentResult.error;\n    }\n  }\n\n  return observer.options.notifyOnChangeProps === 'tracked' ? observer.getTrackedCurrentResult() : currentResult;\n}","map":{"version":3,"sources":["/Users/nicjaws/Documents/GitHub/React/discord-clone/client/node_modules/react-query/es/react/useBaseQuery.js"],"names":["React","notifyManager","useQueryErrorResetBoundary","useQueryClient","useIsMounted","useBaseQuery","options","Observer","isMounted","queryClient","errorResetBoundary","defaultedOptions","defaultQueryObserverOptions","onError","batchCalls","onSuccess","onSettled","suspense","staleTime","isReset","retryOnMount","observerRef","useRef","observer","current","hasListeners","setOptions","currentResult","getCurrentResult","_React$useState","useState","setCurrentResult","useEffect","clearReset","subscribe","result","useErrorBoundary","isLoading","unsubscribe","refetch","finally","isError","error","notifyOnChangeProps","getTrackedCurrentResult"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { notifyManager } from '../core/notifyManager';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary';\nimport { useQueryClient } from './QueryClientProvider';\nimport { useIsMounted } from './useIsMounted';\nexport function useBaseQuery(options, Observer) {\n  var isMounted = useIsMounted();\n  var queryClient = useQueryClient();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly re-mounting after suspense\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    } // Prevent retrying failed query if the error boundary has not been reset yet\n\n\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  } // Create query observer\n\n\n  var observerRef = React.useRef();\n  var observer = observerRef.current || new Observer(queryClient, defaultedOptions);\n  observerRef.current = observer; // Update options\n\n  if (observer.hasListeners()) {\n    observer.setOptions(defaultedOptions);\n  }\n\n  var currentResult = observer.getCurrentResult();\n\n  var _React$useState = React.useState(currentResult),\n      setCurrentResult = _React$useState[1]; // Subscribe to the observer\n\n\n  React.useEffect(function () {\n    errorResetBoundary.clearReset();\n    return observer.subscribe(notifyManager.batchCalls(function (result) {\n      if (isMounted()) {\n        setCurrentResult(result);\n      }\n    }));\n  }, [observer, errorResetBoundary, isMounted]); // Handle suspense\n\n  if (observer.options.suspense || observer.options.useErrorBoundary) {\n    if (observer.options.suspense && currentResult.isLoading) {\n      errorResetBoundary.clearReset();\n      var unsubscribe = observer.subscribe();\n      throw observer.refetch().finally(unsubscribe);\n    }\n\n    if (currentResult.isError) {\n      throw currentResult.error;\n    }\n  }\n\n  return observer.options.notifyOnChangeProps === 'tracked' ? observer.getTrackedCurrentResult() : currentResult;\n}"]},"metadata":{},"sourceType":"module"}